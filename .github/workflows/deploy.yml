name: FastAPI SaaS CI/CD Pipeline

on:
  push:
    branches: [main, develop, 'release/**']

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/release/')) && 'production' || 'staging' }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}
    
    - name: Build and Push Docker Image to ECR
      run: |
        ENVIRONMENT=${{ (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/release/')) && 'production' || 'staging' }}
        ECR_REPOSITORY="fastapi-$ENVIRONMENT"
        AWS_REGION=${{ secrets.AWS_REGION || 'us-east-1' }}
        SHORT_SHA=$(echo ${{ github.sha }} | head -c 7)
        
        # Check if ECR repository exists
        ECR_URI=$(aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION --query 'repositories[0].repositoryUri' --output text 2>/dev/null || echo "")
        
        if [ -z "$ECR_URI" ]; then
          echo "::error::ECR repository '$ECR_REPOSITORY' not found. Please deploy the CDK infrastructure first by running 'cdk deploy' locally."
          echo "Run: cd infra && cdk deploy FastAPIEC2Stack-${ENVIRONMENT^}"
          exit 1
        fi
        
        echo "Found ECR repository: $ECR_URI"
        
        # Login to ECR
        aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_URI
        
        # Build Docker image
        docker build -t $ECR_REPOSITORY .
        
        if [ "$ENVIRONMENT" = "staging" ]; then
          # Staging: tag with staging-shortsha
          IMAGE_TAG="staging-$SHORT_SHA"
          docker tag $ECR_REPOSITORY $ECR_URI:$IMAGE_TAG
          docker push $ECR_URI:$IMAGE_TAG
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
        else
          # Production: tag with latest and release-semver
          docker tag $ECR_REPOSITORY $ECR_URI:latest
          docker push $ECR_URI:latest
          
          # Extract semver from release branch or use commit for main
          if [[ "${{ github.ref }}" == refs/heads/release/* ]]; then
            SEMVER=$(echo "${{ github.ref }}" | sed 's/refs\/heads\/release\///')
            RELEASE_TAG="release-$SEMVER"
          else
            # Fallback for direct main branch pushes
            RELEASE_TAG="release-$(date +%Y.%m.%d)-$SHORT_SHA"
          fi
          
          docker tag $ECR_REPOSITORY $ECR_URI:$RELEASE_TAG
          docker push $ECR_URI:$RELEASE_TAG
          echo "IMAGE_TAG=$RELEASE_TAG" >> $GITHUB_ENV
        fi
        
        echo "ECR_URI=$ECR_URI" >> $GITHUB_ENV
    
    - name: Get Stack Information
      run: |
        # Get stack information from existing infrastructure
        STACK_NAME="FastAPIEC2Stack-${{ (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/release/')) && 'Production' || 'Staging' }}"
        
        # Check if stack exists
        STACK_EXISTS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].StackName' --output text 2>/dev/null || echo "")
        
        if [ -z "$STACK_EXISTS" ]; then
          echo "::warning::CloudFormation stack '$STACK_NAME' not found. Infrastructure should be deployed locally first."
          echo "Run: cd infra && cdk deploy $STACK_NAME"
        else
          # Get EC2 instance info if available
          INSTANCE_ID=$(aws cloudformation describe-stacks \
            --stack-name $STACK_NAME \
            --query "Stacks[0].Outputs[?OutputKey=='EC2InstanceId'].OutputValue" \
            --output text 2>/dev/null || echo "")
          
          if [ ! -z "$INSTANCE_ID" ]; then
            EC2_HOST=$(aws ec2 describe-instances \
              --instance-ids $INSTANCE_ID \
              --query "Reservations[0].Instances[0].PublicIpAddress" \
              --output text 2>/dev/null || echo "")
            
            if [ ! -z "$EC2_HOST" ]; then
              # Export EC2_HOST for the next step
              echo "EC2_HOST=$EC2_HOST" >> $GITHUB_ENV
              echo "ENVIRONMENT=${{ (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/release/')) && 'Production' || 'Staging' }}" >> $GITHUB_ENV
              echo "Found EC2 instance at: $EC2_HOST"
            fi
          fi
        fi
    
    - name: Comment Deployment URL on PR
      if: github.event_name == 'push' && env.EC2_HOST != ''
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const environment = process.env.ENVIRONMENT;
          const ec2Host = process.env.EC2_HOST;
          const deploymentUrl = `http://${ec2Host}:8000`;
          
          // Get the current branch
          const branch = context.ref.replace('refs/heads/', '');
          
          // Find any open PRs from the current branch
          const { data: pulls } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            head: `${context.repo.owner}:${branch}`
          });
          
          const commitSha = context.sha;
          
          for (const pull of pulls) {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pull.number,
              body: `## ðŸš€ Deployment Successful!\n\n**Environment:** ${environment}\n**URL:** ${deploymentUrl}\n**API Documentation:** ${deploymentUrl}/docs\n\n---\n*Deployed from commit ${commitSha.substring(0, 7)} on branch ${branch}*`
            });
          }