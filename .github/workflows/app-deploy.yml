name: ðŸš€ Application Deployment

on:
  push:
    branches: [main, develop, 'release/**']
    paths: ['app/**', 'Dockerfile', 'requirements.txt']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r app/requirements.txt
        pip install pytest pytest-cov flake8 black
    
    - name: Run tests
      run: |
        pytest --cov=app --cov-report=xml --cov-report=html
    
    - name: Run linting
      run: |
        flake8 app --max-line-length=127
        black --check app/
  
  setup:
    uses: ./.github/workflows/shared-setup.yml
    with:
      environment: ${{ inputs.environment || '' }}
    secrets: inherit
  
  deploy-application:
    name: Deploy App to ${{ needs.setup.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [test, setup]
    environment: ${{ needs.setup.outputs.environment }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ needs.setup.outputs.aws-region }}
    
    - name: Build and Push Docker Image to ECR
      run: |
        ENVIRONMENT="${{ needs.setup.outputs.environment }}"
        ECR_REPOSITORY="fastapi-$ENVIRONMENT"
        AWS_REGION="${{ needs.setup.outputs.aws-region }}"
        SHORT_SHA=$(echo ${{ github.sha }} | head -c 7)
        
        # Check if ECR repository exists (should be created by infrastructure pipeline)
        ECR_URI=$(aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION --query 'repositories[0].repositoryUri' --output text 2>/dev/null || echo "")
        
        if [ -z "$ECR_URI" ]; then
          echo "::error::ðŸ—ï¸ ECR repository '$ECR_REPOSITORY' not found. Please deploy the infrastructure first."
          echo "ðŸ› ï¸ Manual: cd infra && cdk deploy FastAPIEC2Stack-${ENVIRONMENT^}"
          echo "ðŸ¤– Automated: Trigger the infrastructure pipeline manually"
          exit 1
        fi
        
        echo "ðŸ“¦ Found ECR repository: $ECR_URI"
        
        # Login to ECR
        aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_URI
        
        # Build Docker image
        docker build -t $ECR_REPOSITORY .
        
        # Tag and push based on environment
        case "$ENVIRONMENT" in
          "staging")
            # Staging: tag with staging-shortsha and latest
            IMAGE_TAG="staging-$SHORT_SHA"
            docker tag $ECR_REPOSITORY $ECR_URI:$IMAGE_TAG
            docker tag $ECR_REPOSITORY $ECR_URI:latest
            docker push $ECR_URI:$IMAGE_TAG
            docker push $ECR_URI:latest
            echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
            ;;
            
          "production-blue")
            # Production-Blue: tag for release testing
            if [[ "${{ github.ref }}" == refs/heads/release/* ]]; then
              SEMVER=$(echo "${{ github.ref }}" | sed 's/refs\/heads\/release\///')
              IMAGE_TAG="blue-$SEMVER-$SHORT_SHA"
            else
              IMAGE_TAG="blue-$SHORT_SHA"
            fi
            docker tag $ECR_REPOSITORY $ECR_URI:$IMAGE_TAG
            docker tag $ECR_REPOSITORY $ECR_URI:latest
            docker push $ECR_URI:$IMAGE_TAG
            docker push $ECR_URI:latest
            echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
            ;;
            
          "production-green")
            # Production-Green: tag for live production
            docker tag $ECR_REPOSITORY $ECR_URI:latest
            docker push $ECR_URI:latest
            
            # Create release tag
            if [[ "${{ github.ref }}" == refs/heads/main ]]; then
              RELEASE_TAG="green-$(date +%Y.%m.%d)-$SHORT_SHA"
            else
              RELEASE_TAG="green-$SHORT_SHA"
            fi
            
            docker tag $ECR_REPOSITORY $ECR_URI:$RELEASE_TAG
            docker push $ECR_URI:$RELEASE_TAG
            echo "IMAGE_TAG=$RELEASE_TAG" >> $GITHUB_ENV
            ;;
            
          *)
            echo "::error::Unknown environment: $ENVIRONMENT"
            exit 1
            ;;
        esac
        
        echo "ECR_URI=$ECR_URI" >> $GITHUB_ENV
        echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV
    
    - name: Trigger EC2 Deployment Update
      id: get-deployment-url
      run: |
        ENVIRONMENT="${{ needs.setup.outputs.environment }}"
        
        # Map environment to stack name
        case "$ENVIRONMENT" in
          "staging")
            STACK_NAME="FastAPIEC2Stack-Staging"
            ;;
          "production-blue")
            STACK_NAME="FastAPIEC2Stack-ProductionBlue"
            ;;
          "production-green")
            STACK_NAME="FastAPIEC2Stack-ProductionGreen"
            ;;
          *)
            echo "::error::Unknown environment: $ENVIRONMENT"
            exit 1
            ;;
        esac
        
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        AWS_REGION="${{ needs.setup.outputs.aws-region }}"
        
        echo "ðŸ” Looking for stack: $STACK_NAME"
        echo "ðŸ“ Environment: $ENVIRONMENT"
        echo "ðŸŒŽ Region: $AWS_REGION"
        
        # Check if stack exists
        STACK_EXISTS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].StackName' --output text 2>/dev/null || echo "")
        
        if [ -z "$STACK_EXISTS" ]; then
          echo "::warning::CloudFormation stack '$STACK_NAME' not found. Infrastructure should be deployed first."
          exit 0  # Don't fail, just skip deployment
        fi
        
        # Get Auto Scaling Group name from stack
        echo "ðŸ“‹ Fetching Auto Scaling Group from stack..."
        ASG_NAME=$(aws cloudformation describe-stack-resources \
          --stack-name $STACK_NAME \
          --query "StackResources[?ResourceType=='AWS::AutoScaling::AutoScalingGroup'].PhysicalResourceId" \
          --output text 2>/dev/null || echo "")
        
        if [ ! -z "$ASG_NAME" ]; then
          echo "âœ… Found Auto Scaling Group: $ASG_NAME"
          echo "ðŸ”„ Triggering instance refresh..."
          
          # Start instance refresh to pull new Docker image
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name $ASG_NAME \
            --preferences '{"MinHealthyPercentage": 90, "InstanceWarmup": 60}' \
            --query 'InstanceRefreshId' \
            --output text 2>/dev/null || echo "")
          
          if [ ! -z "$REFRESH_ID" ]; then
            echo "âœ… Instance refresh started: $REFRESH_ID"
            echo "â³ EC2 instances will pull the new Docker image from ECR"
          else
            echo "::warning::Could not start instance refresh. Manual deployment may be required."
          fi
        else
          echo "::warning::No Auto Scaling Group found in stack $STACK_NAME"
        fi
        
        # Get Load Balancer DNS from CloudFormation stack outputs
        LB_DNS=$(aws cloudformation describe-stacks \
          --stack-name $STACK_NAME \
          --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" \
          --output text 2>/dev/null || echo "")
        
        if [ ! -z "$LB_DNS" ]; then
          echo "LB_DNS=$LB_DNS" >> $GITHUB_ENV
          echo "DEPLOYMENT_URL=http://$LB_DNS" >> $GITHUB_ENV
          echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
          echo "AWS_REGION=$AWS_REGION" >> $GITHUB_ENV
          
          echo "ðŸš€ Application deployment initiated!"
          echo "ðŸ“ Load Balancer DNS: $LB_DNS"
          echo "ðŸ”— Application URL: http://$LB_DNS"
          echo "ðŸ“š API Documentation: http://$LB_DNS/docs"
          echo "ðŸ”’ Application pulls configuration from AWS Secrets Manager"
          
          # Set GitHub Actions output
          echo "deployment_url=http://$LB_DNS" >> $GITHUB_OUTPUT
          echo "load_balancer_dns=$LB_DNS" >> $GITHUB_OUTPUT
        else
          echo "::warning::Could not retrieve Load Balancer DNS from stack"
        fi
    
    - name: Deployment Summary
      if: steps.get-deployment-url.outputs.load_balancer_dns != ''
      run: |
        echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Environment: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”— Clickable URLs" >> $GITHUB_STEP_SUMMARY
        echo "| Service | URL |" >> $GITHUB_STEP_SUMMARY
        echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
        echo "| **ðŸŒ Application** | [http://${{ env.LB_DNS }}](http://${{ env.LB_DNS }}) |" >> $GITHUB_STEP_SUMMARY
        echo "| **ðŸ“š API Documentation** | [http://${{ env.LB_DNS }}/docs](http://${{ env.LB_DNS }}/docs) |" >> $GITHUB_STEP_SUMMARY
        echo "| **â¤ï¸ Health Check** | [http://${{ env.LB_DNS }}/health](http://${{ env.LB_DNS }}/health) |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“Š Deployment Details" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Value |" >> $GITHUB_STEP_SUMMARY
        echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
        echo "| **Environment Type** | ${{ needs.setup.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
        echo "| **Load Balancer DNS** | \`${{ env.LB_DNS }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Docker Image Tag** | \`${{ env.IMAGE_TAG }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Branch** | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Commit** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Environment-specific notes
        if [[ "${{ needs.setup.outputs.environment }}" == "staging" ]]; then
          echo "### ðŸ“ STAGING Environment" >> $GITHUB_STEP_SUMMARY
          echo "- Continuous integration testing for develop branch" >> $GITHUB_STEP_SUMMARY
        elif [[ "${{ needs.setup.outputs.environment }}" == "production-blue" ]]; then
          echo "### ðŸ”µ PRODUCTION-BLUE Environment" >> $GITHUB_STEP_SUMMARY
          echo "- Isolated release testing environment" >> $GITHUB_STEP_SUMMARY
          echo "- Test release before promoting to production" >> $GITHUB_STEP_SUMMARY
        elif [[ "${{ needs.setup.outputs.environment }}" == "production-green" ]]; then
          echo "### ðŸŸ¢ PRODUCTION-GREEN Environment" >> $GITHUB_STEP_SUMMARY
          echo "- Live production environment" >> $GITHUB_STEP_SUMMARY
          echo "- Serving actual user traffic" >> $GITHUB_STEP_SUMMARY
        fi
    
    - name: Comment Deployment URL on PR
      if: github.event_name == 'pull_request' && env.LB_DNS != ''
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const environment = process.env.ENVIRONMENT;
          const lbDns = process.env.LB_DNS;
          const deploymentUrl = process.env.DEPLOYMENT_URL;
          const imageTag = process.env.IMAGE_TAG;
          
          // Get the current branch
          const branch = context.ref.replace('refs/heads/', '');
          
          // Find any open PRs from the current branch
          const { data: pulls } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            head: `${context.repo.owner}:${branch}`
          });
          
          const commitSha = context.sha;
          
          for (const pull of pulls) {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pull.number,
              body: `## ðŸš€ Application Deployment Successful!\n\n**Environment:** ${environment}\n**URL:** ${deploymentUrl}\n**API Documentation:** ${deploymentUrl}/docs\n**Docker Tag:** ${imageTag}\n\n*App pulls config from AWS Secrets Manager automatically*\n\n---\n*Deployed from commit ${commitSha.substring(0, 7)} on branch ${branch}*`
            });
          }