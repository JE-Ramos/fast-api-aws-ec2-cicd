name: 🚀 Application Deployment

on:
  push:
    branches: [main, develop, 'release/**']
    paths: ['app/**', 'Dockerfile', 'requirements.txt']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r app/requirements.txt
        pip install pytest pytest-cov
    
    - name: Run tests
      run: |
        pytest --cov=app --cov-report=xml --cov-report=html
    
    - name: Run linting
      run: |
        flake8 app --max-line-length=127
        black --check app/
  
  setup:
    uses: ./.github/workflows/shared-setup.yml
    with:
      environment: ${{ inputs.environment || '' }}
    secrets: inherit
  
  deploy-application:
    name: Deploy App to ${{ needs.setup.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [test, setup]
    environment: ${{ needs.setup.outputs.environment }}
    outputs:
      deployment-url: ${{ steps.get-deployment-url.outputs.deployment_url }}
      load-balancer-dns: ${{ steps.get-deployment-url.outputs.load_balancer_dns }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ needs.setup.outputs.aws-region }}
    
    - name: Build and Push Docker Image to ECR
      run: |
        ENVIRONMENT="${{ needs.setup.outputs.environment }}"
        ECR_REPOSITORY="fastapi-$ENVIRONMENT"
        AWS_REGION="${{ needs.setup.outputs.aws-region }}"
        SHORT_SHA=$(echo ${{ github.sha }} | head -c 7)
        
        # Check if ECR repository exists (should be created by infrastructure pipeline)
        ECR_URI=$(aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION --query 'repositories[0].repositoryUri' --output text 2>/dev/null || echo "")
        
        if [ -z "$ECR_URI" ]; then
          echo "::error::🏗️ ECR repository '$ECR_REPOSITORY' not found. Please deploy the infrastructure first."
          echo "🛠️ Manual: cd infra && cdk deploy FastAPIEC2Stack-${ENVIRONMENT^}"
          echo "🤖 Automated: Trigger the infrastructure pipeline manually"
          exit 1
        fi
        
        echo "📦 Found ECR repository: $ECR_URI"
        
        # Login to ECR
        aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_URI
        
        # Build Docker image
        docker build -t $ECR_REPOSITORY .
        
        if [ "$ENVIRONMENT" = "staging" ]; then
          # Staging: tag with staging-shortsha
          IMAGE_TAG="staging-$SHORT_SHA"
          docker tag $ECR_REPOSITORY $ECR_URI:$IMAGE_TAG
          docker push $ECR_URI:$IMAGE_TAG
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
        else
          # Production: tag with latest and release-semver
          docker tag $ECR_REPOSITORY $ECR_URI:latest
          docker push $ECR_URI:latest
          
          # Extract semver from release branch or use commit for main
          if [[ "${{ github.ref }}" == refs/heads/release/* ]]; then
            SEMVER=$(echo "${{ github.ref }}" | sed 's/refs\/heads\/release\///')
            RELEASE_TAG="release-$SEMVER"
          else
            # Fallback for direct main branch pushes
            RELEASE_TAG="release-$(date +%Y.%m.%d)-$SHORT_SHA"
          fi
          
          docker tag $ECR_REPOSITORY $ECR_URI:$RELEASE_TAG
          docker push $ECR_URI:$RELEASE_TAG
          echo "IMAGE_TAG=$RELEASE_TAG" >> $GITHUB_ENV
        fi
        
        echo "ECR_URI=$ECR_URI" >> $GITHUB_ENV
        echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV
    
    - name: Trigger EC2 Deployment Update
      id: get-deployment-url
      run: |
        STACK_NAME="FastAPIEC2Stack-${{ needs.setup.outputs.environment }}"
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        AWS_REGION="${{ needs.setup.outputs.aws-region }}"
        ENVIRONMENT="${{ needs.setup.outputs.environment }}"
        
        # Check if stack exists
        STACK_EXISTS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].StackName' --output text 2>/dev/null || echo "")
        
        if [ -z "$STACK_EXISTS" ]; then
          echo "::warning::CloudFormation stack '$STACK_NAME' not found. Infrastructure should be deployed first."
          exit 0  # Don't fail, just skip deployment
        fi
        
        # Get Auto Scaling Group name from stack
        ASG_NAME=$(aws cloudformation describe-stack-resources \
          --stack-name $STACK_NAME \
          --query "StackResources[?ResourceType=='AWS::AutoScaling::AutoScalingGroup'].PhysicalResourceId" \
          --output text 2>/dev/null || echo "")
        
        if [ ! -z "$ASG_NAME" ]; then
          echo "🔄 Triggering instance refresh for Auto Scaling Group: $ASG_NAME"
          
          # Start instance refresh to pull new Docker image
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name $ASG_NAME \
            --preferences '{"MinHealthyPercentage": 90, "InstanceWarmup": 60}' \
            --query 'InstanceRefreshId' \
            --output text 2>/dev/null || echo "")
          
          if [ ! -z "$REFRESH_ID" ]; then
            echo "✅ Instance refresh started: $REFRESH_ID"
            echo "⏳ EC2 instances will pull the new Docker image from ECR"
          else
            echo "::warning::Could not start instance refresh. Manual deployment may be required."
          fi
        fi
        
        # Get Load Balancer DNS from CloudFormation stack outputs
        LB_DNS=$(aws cloudformation describe-stacks \
          --stack-name $STACK_NAME \
          --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" \
          --output text 2>/dev/null || echo "")
        
        if [ ! -z "$LB_DNS" ]; then
          echo "LB_DNS=$LB_DNS" >> $GITHUB_ENV
          echo "DEPLOYMENT_URL=http://$LB_DNS" >> $GITHUB_ENV
          echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
          echo "AWS_REGION=$AWS_REGION" >> $GITHUB_ENV
          
          echo "🚀 Application deployment initiated!"
          echo "📍 Load Balancer DNS: $LB_DNS"
          echo "🔗 Application URL: http://$LB_DNS"
          echo "📚 API Documentation: http://$LB_DNS/docs"
          echo "🔒 Application pulls configuration from AWS Secrets Manager"
          
          # Set GitHub Actions output
          echo "deployment_url=http://$LB_DNS" >> $GITHUB_OUTPUT
          echo "load_balancer_dns=$LB_DNS" >> $GITHUB_OUTPUT
        else
          echo "::warning::Could not retrieve Load Balancer DNS from stack"
        fi
    
    - name: Deployment Summary
      if: env.LB_DNS != ''
      run: |
        echo "## 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Environment: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🔗 Clickable URLs" >> $GITHUB_STEP_SUMMARY
        echo "| Service | URL |" >> $GITHUB_STEP_SUMMARY
        echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
        echo "| **🌐 Application** | [http://${{ env.LB_DNS }}](http://${{ env.LB_DNS }}) |" >> $GITHUB_STEP_SUMMARY
        echo "| **📚 API Documentation** | [http://${{ env.LB_DNS }}/docs](http://${{ env.LB_DNS }}/docs) |" >> $GITHUB_STEP_SUMMARY
        echo "| **❤️ Health Check** | [http://${{ env.LB_DNS }}/health](http://${{ env.LB_DNS }}/health) |" >> $GITHUB_STEP_SUMMARY
        echo "| **🐳 ECR Repository** | [View in AWS Console](https://console.aws.amazon.com/ecr/repositories/private/${{ env.AWS_ACCOUNT_ID }}/fastapi-${{ needs.setup.outputs.environment }}?region=${{ env.AWS_REGION }}) |" >> $GITHUB_STEP_SUMMARY
        echo "| **📦 ECR Images** | [View Images](https://console.aws.amazon.com/ecr/repositories/private/${{ env.AWS_ACCOUNT_ID }}/fastapi-${{ needs.setup.outputs.environment }}/images?region=${{ env.AWS_REGION }}) |" >> $GITHUB_STEP_SUMMARY
        echo "| **⚖️ Load Balancer** | [View in AWS Console](https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }}#LoadBalancers:) |" >> $GITHUB_STEP_SUMMARY
        echo "| **🖥️ EC2 Instances** | [View in AWS Console](https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }}#Instances:) |" >> $GITHUB_STEP_SUMMARY
        echo "| **🔐 Secrets Manager** | [View Secrets](https://console.aws.amazon.com/secretsmanager/home?region=${{ env.AWS_REGION }}#/listSecrets) |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📊 Deployment Details" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Value |" >> $GITHUB_STEP_SUMMARY
        echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
        echo "| **Load Balancer DNS** | \`${{ env.LB_DNS }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Docker Image Tag** | \`${{ env.IMAGE_TAG }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **ECR URI** | \`${{ env.ECR_URI }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Full Image** | \`${{ env.ECR_URI }}:${{ env.IMAGE_TAG }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🔍 Deployment Info" >> $GITHUB_STEP_SUMMARY
        echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
        echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
        echo "| **Branch** | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Commit** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Triggered by** | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
        echo "| **Workflow Run** | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ℹ️ Notes" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ ECR image pushed successfully" >> $GITHUB_STEP_SUMMARY
        echo "- 🔄 Instance refresh triggered - EC2 instances pulling new image" >> $GITHUB_STEP_SUMMARY
        echo "- 🔒 Application pulls configuration from AWS Secrets Manager" >> $GITHUB_STEP_SUMMARY
        echo "- ⏳ Full deployment may take 2-3 minutes for instance refresh" >> $GITHUB_STEP_SUMMARY
    
    - name: Comment Deployment URL on PR
      if: github.event_name == 'pull_request' && env.LB_DNS != ''
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const environment = process.env.ENVIRONMENT;
          const lbDns = process.env.LB_DNS;
          const deploymentUrl = process.env.DEPLOYMENT_URL;
          const imageTag = process.env.IMAGE_TAG;
          const commitSha = context.sha;
          
          // Comment on the PR that triggered this workflow
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: `## 🚀 Application Deployment Successful!\n\n**Environment:** ${environment}\n**URL:** ${deploymentUrl}\n**API Documentation:** ${deploymentUrl}/docs\n**Docker Tag:** ${imageTag}\n\n*App pulls config from AWS Secrets Manager automatically*\n\n---\n*Deployed from commit ${commitSha.substring(0, 7)}*`
          });